# Handling string concatenation in generated bytecode

A recent `java.lang.VerifyError` in `obj/torch.short()` exposed that the
compiler emitted integer addition (`iadd`) even when the LPC source was
concatenating strings. The affected bytecode tried to add an `int` to a
`java/lang/String`, which the verifier rejected. This happened because a
field that was initialized to `0` was later used in a string expression, but
both the type inference and code generation paths still treated `+` as a
numeric operation.

## What changed
- **Type inference** now treats any `+` expression with a string operand as a
  string expression, even if only one side is a string. This avoids falling
  back to integer arithmetic when one operand was inferred as numeric.
- **Code generation** now emits `StringBuilder`-based concatenation whenever
  the expression type is string. Non-string additions still use integer
  opcodes (`iadd`).

Together these changes ensure the generated bytecode matches LPC semantics
for string concatenation and remains verifier-safe even when variables are
initialized with numeric sentinels before being assigned strings.

## Examples of scenarios now handled correctly
- Concatenating a field that starts as `0` but later stores text:
  ```lpc
  string title;
  reset() {
      title = 0; // sentinel while loading
  }
  set_title(string t) { title = t; }
  short() { return title + " (ready)"; }
  ```
- Mixing literals and computed strings:
  ```lpc
  string prefix;
  short() { return prefix + " count: " + number_to_string(query_weight()); }
  ```
- Building descriptions incrementally:
  ```lpc
  string desc;
  short() {
      string base = desc;
      if (query_light())
          base = base + " (lit)";
      return base;
  }
  ```

## Original LPC snippet that triggered the verifier error
The fix specifically targets the `short()` implementation from
`lpc2j.test.lpmud.obj.torch`:

```lpc
short() {
    if (is_lit)
        return name + " (lit)";
    if (amount_of_fuel == 0)
        return name + " (burnt out)";
    return name;
}
```

This method now compiles to safe string-concatenation bytecode instead of an
invalid integer addition.
