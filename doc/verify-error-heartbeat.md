# Fixing heart_beat() unary minus verification failures

A recent verification failure surfaced when compiling `obj/torch`:

```
java.lang.VerifyError: Bad type on operand stack
Exception Details:
  Location:
    obj/torch.heart_beat()Ljava/lang/Object; @291: ineg
  Reason:
    Type 'java/lang/Object' (current frame, stack[6]) is not assignable to integer
```

The generated bytecode used the integer negation (`INEG`) opcode even when the
operand on the stack was a boxed `Object`.  When an LPC variable is backed by an
`Object` slot (for example when the type is inferred as `mixed`) and then passed
through a unary minus, the verifier rejects the method because the operand is
not a primitive integer.

The compiler now normalizes unary-minus operands by unboxing `Number`
instances before applying `INEG`, and emits `FNEG` when the operand is a
floating-point value.  This keeps the operand stack consistent for the JVM
verifier while preserving LPC semantics for numeric values stored in mixed
slots.

## LPC cases covered by the change

### Mixed numeric values negated in place

```
mixed delta;

delta = 5;
return -delta;  /* now safely unboxed before INEG */
```

### Floats passed through unary minus

```
float penalty;

penalty = 2.5;
return -penalty;  /* now uses FNEG */
```

### Exact code fixed from `lpc2j.test.lpmud.obj.torch`

The heart beat in `obj/torch` negates the stored weight when adjusting the
carrier's load.  This method now compiles without verifier errors:

```
heart_beat() {
    object ob;
    if (!is_lit)
        return;
    amount_of_fuel -= 1;
    if (amount_of_fuel > 0)
        return;
    say(name + " goes dark.\n");
    set_heart_beat(0);
    is_lit = 0;
    set_light(-1);
    ob = environment();
    if (call_other(ob, "query_level"))
        call_other(ob, "add_weight", -weight);
    destruct(this_object());
}
```
