package io.github.protasm.lpc2j.exec;

import io.github.protasm.lpc2j.efun.Efun;
import io.github.protasm.lpc2j.parser.ast.ASTObject;
import io.github.protasm.lpc2j.pipeline.CompilationPipeline;
import io.github.protasm.lpc2j.pipeline.CompilationProblem;
import io.github.protasm.lpc2j.pipeline.CompilationResult;
import io.github.protasm.lpc2j.pipeline.CompilationUnit;
import io.github.protasm.lpc2j.parser.ParserOptions;
import io.github.protasm.lpc2j.runtime.RuntimeContext;
import io.github.protasm.lpc2j.runtime.RuntimeContextHolder;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.function.Supplier;

/**
 * Host-facing LPC execution runtime that owns classloading, object identity, and runtime context.
 *
 * <p>This runtime is distinct from {@code io.github.protasm.lpc2j.runtime}, which contains the
 * language-level helpers used by generated bytecode. {@code LpcRuntime} sits above the compiler
 * pipeline and provides a minimal API for loading LPC objects from source code.</p>
 *
 * <p>Usage example:</p>
 *
 * <pre>{@code
 * LpcRuntime runtime = new LpcRuntime(LpcRuntimeConfig.builder()
 *         .baseIncludePath(Path.of("mudlib"))
 *         .build());
 * LpcObjectHandle orc = runtime.load("/obj/orc.c");
 * runtime.withRuntimeContext(() -> {
 *     orc.instance().getClass().getMethod("init").invoke(orc.instance());
 *     return null;
 * });
 * }</pre>
 */
public final class LpcRuntime {
    private final LpcRuntimeClassLoader classLoader;
    private final RuntimeContext runtimeContext;
    private final CompilationPipeline pipeline;
    private final Path baseIncludePath;

    public LpcRuntime(LpcRuntimeConfig config) {
        Objects.requireNonNull(config, "config");
        this.baseIncludePath = config.baseIncludePath();
        this.runtimeContext = new RuntimeContext(config.resolveIncludeResolver());
        this.classLoader = new LpcRuntimeClassLoader(config.parentClassLoader());
        this.pipeline = new CompilationPipeline(config.parentInternalName(), runtimeContext);
    }

    public LpcObjectHandle load(String sourcePath) {
        Objects.requireNonNull(sourcePath, "sourcePath");
        return load(resolveSourcePathWithExtensions(sourcePath));
    }

    public LpcObjectHandle load(Path sourcePath) {
        Objects.requireNonNull(sourcePath, "sourcePath");
        Path normalized = resolveSourcePathWithExtensions(sourcePath);
        String source;

        try {
            source = Files.readString(normalized);
        } catch (IOException e) {
            throw new LpcRuntimeException("Failed to read source file: " + normalized, e);
        }

        String sourceName = deriveSourceName(normalized, baseIncludePath);
        String displayPath = "/" + sourceName;
        CompilationResult result =
                pipeline.run(normalized, source, sourceName, displayPath, ParserOptions.defaults());

        if (!result.getProblems().isEmpty()) {
            throw new LpcRuntimeException(formatProblems(result.getProblems()), result.getProblems());
        }

        CompilationUnit compilationUnit = result.getCompilationUnit();
        if (compilationUnit != null) {
            defineInheritedClasses(compilationUnit.parentUnit());
        }

        byte[] bytecode = result.getBytecode();
        if (bytecode == null) {
            throw new LpcRuntimeException("Compilation did not produce bytecode for " + sourceName);
        }

        String internalName = (result.getAstObject() != null) ? result.getAstObject().name() : sourceName;
        internalName = normalizeInternalName(internalName);
        Class<?> compiledClass = classLoader.defineClass(internalName, bytecode);
        Object instance = instantiate(compiledClass);

        runtimeContext.registerObject(internalName, instance);

        return new LpcObjectHandle(this, internalName, compiledClass, instance);
    }

    public LpcObjectHandle loadSource(String sourceName, String source) {
        Objects.requireNonNull(sourceName, "sourceName");
        Objects.requireNonNull(source, "source");
        String normalizedName = normalizeInternalName(stripExtension(sourceName));
        String displayPath = "/" + normalizedName;

        CompilationResult result =
                pipeline.run(null, source, normalizedName, displayPath, ParserOptions.defaults());

        if (!result.getProblems().isEmpty()) {
            throw new LpcRuntimeException(formatProblems(result.getProblems()), result.getProblems());
        }

        CompilationUnit compilationUnit = result.getCompilationUnit();
        if (compilationUnit != null) {
            defineInheritedClasses(compilationUnit.parentUnit());
        }

        byte[] bytecode = result.getBytecode();
        if (bytecode == null) {
            throw new LpcRuntimeException("Compilation did not produce bytecode for " + normalizedName);
        }

        String internalName = (result.getAstObject() != null) ? result.getAstObject().name() : normalizedName;
        internalName = normalizeInternalName(internalName);
        Class<?> compiledClass = classLoader.defineClass(internalName, bytecode);
        Object instance = instantiate(compiledClass);

        runtimeContext.registerObject(internalName, instance);

        return new LpcObjectHandle(this, internalName, compiledClass, instance);
    }

    public void registerEfun(Efun efun) {
        runtimeContext.registerEfun(efun);
    }

    public <T> T withRuntimeContext(Supplier<T> action) {
        Objects.requireNonNull(action, "action");
        RuntimeContext previous = RuntimeContextHolder.current();
        RuntimeContextHolder.setCurrent(runtimeContext);
        try {
            return action.get();
        } finally {
            RuntimeContextHolder.setCurrent(previous);
        }
    }

    public <T> T withCurrentObject(Object object, Supplier<T> action) {
        Objects.requireNonNull(action, "action");
        return withRuntimeContext(() -> runtimeContext.withCurrentObject(object, action));
    }

    public void runWithCurrentObject(Object object, Runnable action) {
        Objects.requireNonNull(action, "action");
        withCurrentObject(object, () -> {
            action.run();
            return null;
        });
    }

    public void runWithRuntimeContext(Runnable action) {
        Objects.requireNonNull(action, "action");
        withRuntimeContext(() -> {
            action.run();
            return null;
        });
    }

    private Object instantiate(Class<?> compiledClass) {
        return withRuntimeContext(() -> {
            try {
                return compiledClass.getDeclaredConstructor().newInstance();
            } catch (InstantiationException
                    | IllegalAccessException
                    | InvocationTargetException
                    | NoSuchMethodException e) {
                throw new LpcRuntimeException("Failed to instantiate LPC object: " + compiledClass.getName(), e);
            }
        });
    }

    private Path resolveSourcePath(String sourcePath) {
        Path raw = Path.of(sourcePath);
        if (raw.isAbsolute() && baseIncludePath != null) {
            String trimmed = sourcePath;
            while (trimmed.startsWith("/")) {
                trimmed = trimmed.substring(1);
            }
            if (!trimmed.isEmpty()) {
                return baseIncludePath.resolve(trimmed).normalize();
            }
        }

        if (!raw.isAbsolute() && baseIncludePath != null) {
            return baseIncludePath.resolve(raw).normalize();
        }

        return raw.normalize();
    }

    private Path resolveSourcePathWithExtensions(String sourcePath) {
        Path resolved = resolveSourcePath(sourcePath);
        if (hasExtension(resolved)) {
            return resolved;
        }
        if (Files.exists(resolved)) {
            return resolved;
        }
        Path cCandidate = resolveSourcePath(sourcePath + ".c");
        if (Files.exists(cCandidate)) {
            return cCandidate;
        }
        Path lpcCandidate = resolveSourcePath(sourcePath + ".lpc");
        if (Files.exists(lpcCandidate)) {
            return lpcCandidate;
        }
        return resolved;
    }

    private Path resolveSourcePathWithExtensions(Path sourcePath) {
        Path normalized = normalizeSourcePath(sourcePath);
        if (hasExtension(sourcePath)) {
            return normalized;
        }
        if (Files.exists(normalized)) {
            return normalized;
        }
        Path cCandidate = normalizeSourcePath(appendExtension(sourcePath, ".c"));
        if (Files.exists(cCandidate)) {
            return cCandidate;
        }
        Path lpcCandidate = normalizeSourcePath(appendExtension(sourcePath, ".lpc"));
        if (Files.exists(lpcCandidate)) {
            return lpcCandidate;
        }
        return normalized;
    }

    private Path normalizeSourcePath(Path sourcePath) {
        Path normalized = sourcePath;
        if (!normalized.isAbsolute() && baseIncludePath != null) {
            normalized = baseIncludePath.resolve(normalized);
        }
        return normalized.toAbsolutePath().normalize();
    }

    private Path appendExtension(Path sourcePath, String extension) {
        Path fileName = sourcePath.getFileName();
        if (fileName == null) {
            return sourcePath;
        }
        Path parent = sourcePath.getParent();
        String nameWithExtension = fileName.toString() + extension;
        return (parent == null) ? Path.of(nameWithExtension) : parent.resolve(nameWithExtension);
    }

    private boolean hasExtension(Path sourcePath) {
        Path fileName = sourcePath.getFileName();
        if (fileName == null) {
            return false;
        }
        String name = fileName.toString();
        int dot = name.lastIndexOf('.');
        return dot > 0 && dot < name.length() - 1;
    }

    private String formatProblems(List<CompilationProblem> problems) {
        StringBuilder builder = new StringBuilder("Compilation failed:\n");
        for (CompilationProblem problem : problems) {
            builder.append("- ")
                    .append(problem.getStage())
                    .append(": ")
                    .append(problem.getMessage());
            if (problem.getLine() != null) {
                builder.append(" (line ").append(problem.getLine()).append(")");
            }
            Throwable throwable = problem.getThrowable();
            if ((throwable != null) && (throwable.getMessage() != null)) {
                builder.append(" - ").append(throwable.getMessage());
            }
            builder.append("\n");
        }
        return builder.toString();
    }

    private String normalizeInternalName(String internalName) {
        String normalized = internalName;
        while (normalized.startsWith("/")) {
            normalized = normalized.substring(1);
        }
        return normalized;
    }

    private String deriveSourceName(Path sourcePath, Path basePath) {
        Path normalized = sourcePath.normalize();
        Path base = (basePath != null) ? basePath.normalize() : null;
        Path relative = (base != null && normalized.startsWith(base))
                ? base.relativize(normalized)
                : normalized;
        Path withoutExtension = stripExtension(relative);
        String normalizedName = withoutExtension.normalize().toString().replace('\\', '/');

        while (normalizedName.startsWith("/")) {
            normalizedName = normalizedName.substring(1);
        }

        return normalizedName;
    }

    private String stripExtension(String name) {
        int dot = name.lastIndexOf('.');
        return (dot == -1) ? name : name.substring(0, dot);
    }

    private void defineInheritedClasses(CompilationUnit unit) {
        if (unit == null) {
            return;
        }

        defineInheritedClasses(unit.parentUnit());

        ASTObject astObject = unit.astObject();
        if (astObject == null) {
            return;
        }

        String internalName = normalizeInternalName(astObject.name());
        if (classLoader.isDefined(internalName)) {
            return;
        }

        CompilationResult result =
                pipeline.run(unit.sourcePath(), unit.source(), unit.sourceName(), unit.displayPath(), ParserOptions.defaults());

        if (!result.getProblems().isEmpty()) {
            throw new LpcRuntimeException(formatProblems(result.getProblems()), result.getProblems());
        }

        byte[] bytecode = result.getBytecode();
        if (bytecode == null) {
            throw new LpcRuntimeException("Compilation did not produce bytecode for " + internalName);
        }

        classLoader.defineClass(internalName, bytecode);
    }

    private Path stripExtension(Path path) {
        if (path == null) {
            return Path.of("<input>");
        }

        Path fileName = path.getFileName();
        if (fileName == null) {
            return path;
        }

        String name = fileName.toString();
        int dot = name.lastIndexOf('.');
        String stem = (dot == -1) ? name : name.substring(0, dot);
        Path parent = path.getParent();

        return (parent == null) ? Path.of(stem) : parent.resolve(stem);
    }
}
